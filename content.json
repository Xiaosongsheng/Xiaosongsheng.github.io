{"meta":{"title":"wenhui","subtitle":"","description":"","author":"文慧啊","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"typescript","slug":"typescript","date":"2019-11-22T06:17:53.982Z","updated":"2019-11-22T08:38:09.432Z","comments":true,"path":"2019/11/22/typescript/","link":"","permalink":"http://yoursite.com/2019/11/22/typescript/","excerpt":"","text":"1.工作环境配置 安装npm i -g typescript 编译tsc XXXXX . ts &lt;! –more– &gt; 1.1vscode中如何配置自动编译.ts文件 一.tsc–init 生成tsconfig.json 找到outDirL”./js” 二.点击终端 运行任务 选择监视tsconfig.json 1.2typescript 中的数据类型 为了使编写更加规范 便于维护 增加了类型校验 类型校验: 写ts代码必须指定类型 1.3typescript中的函数1234567891011121314151617181920212223241.函数声明发 function run():string&#123; return &quot;run&quot; &#125;2.匿名函数 var fun2=function():number&#123; return 123; &#125;ts中定义方法传参 function getInfo(name:string,age:number):string&#123; return &quot;$(name)---$(age)&quot; &#125; alert(getInfo(&quot;zhangsan&quot;,20)); function getInfo=function(name:string,age:number):string&#123; return &quot;$(name)---$(age)&quot; &#125; alert(getInfo(&quot;zhangsan&quot;,40));没有返回值得方法 function run:void&#123; console.log(&apos;run&apos;) &#125; run(); 1.3.1方法可选取参数 es5里面方法的实参和形参可以不一样到但是ts中必须要一样 如果不一样就需要配置可选参数(在该参数后面加问号) 12345678function getInfo(name:string,age?:number):string&#123; if(age)&#123; return &quot;$(name)---$(age)&quot; &#125;else&#123; return &quot;$(name)---年龄保密&quot; &#125;&#125;alert(getInfo(&quot;zhangsan&quot;,20)); 注意:可选参数必须配置到参数的最后面 1.3.2默认参数调用方法可以指定一个默认参数 123456789function getInfo(name:string,age:number=20):string&#123; if(age)&#123; return &quot;$(name)---$(age)&quot; &#125;else&#123; return &quot;$(name)---年龄保密&quot; &#125; &#125; alert(getInfo(&quot;zhangsan&quot;)); alert(getInfo(&quot;zhangsan&quot;,30)); 1.3.3剩余参数三点运算符 接受兴参数传过来的值​ 12345678function sum(...result:number):number&#123; var sum=0; for (var i=0;i&lt;result;i++)&#123; sum+=result[i]; &#125; retrun sum &#125; alert(sum(1,2,3)) 1.3.4函数重载java中方法的重载 重载是指两个或者两个以上同名函数,但是他们的参数不一样,这样就会出现函数重载的情况ts中的重载,通过为同一函数提供多个函数类型定义来试下多种功能的目的ts为了兼容es5es6重载的写法和java有区别 123456789101112function getInfo(str:string):stringfonction getInfo(str:number):numberfunction getInfo(str:any):any&#123; if(typeof str===&quot;string&quot;)&#123; return &quot;我叫:&quot;+str; &#125;else&#123; return &quot;我的年龄是&quot;+str; &#125;&#125;alert(getInfo(&quot;张三&quot;))alert(getInfo(&quot;20&quot;))alert(getInfo(true))//错误写法 1.3.5箭头函数123setTimeout(()=&gt;&#123; alert(&apos;run&apos;)&#125;,1000) 注意:this 指向上下文 1.4typescript中的类es5中的类通过构造函数 1.4.1类的定义123456789101112class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet():string &#123; alert(&quot;Hello, &quot; + this.greeting); return &quot;Hello, &quot; + this.greeting; &#125;&#125;let greeter = new Greeter(&quot;world&quot;);greeter.greet() 1.4.2类的继承两个关键字 extends super12345678910111213141516171819202122class Greeter &#123; greeting: string;//属性 前面省略了public关键字 constructor(message: string) &#123;//构造函数 实例化类的时候触发的方法 this.greeting = message; &#125; greet():string &#123; return &quot;Hello, &quot; + this.greeting; &#125;&#125;let greeter = new Greeter(&quot;world&quot;);greeter.greet()alert(greeter.greet())//继承class Web extends Greeter&#123; constructor(message:string)&#123; super(message);//初始化类的数据结构(实例化我们的子例)表示调用父类的构造函数 &#125;&#125;let w = new Web(&quot;李四&quot;);alert(w.greet()) 1.4.3类里面的修饰符typescript里面在定义属性的时候给我们提供了三种修饰符 public 公有 在类里面 子类 类外边都可以访问 protected 保护类型在类里面 子类里面可以访问 在类外面无法访问 private 私有 在类里面 可以访问 子类 类外边无法访问 属性如果不加修饰符 默认就是公有 1.4.4静态方法1.4.5多态父类定义的方法不去实现 让继承他的子类去实现 每个子类有不同的表现 多态也是继承的一种表示 1.4.6抽象方法(标准) typescripit 中的抽象类:他是提供其他类继承的基类,不能实例化 用abstract关键字定义的抽象类和抽象方法 抽象类中多的抽象方法不包含具体的实现并且必须在派生类中实现 abstract抽象方法只能放在抽象类里面 抽象类和抽象方法用来定义标准 (这个类要求他的子类必须实现他的抽象方法) 抽象类中其他方法可以不实现但是抽象方法必须要实现 1.5typescript中的接口(定义标准) 接口的作用*: 在面向对象的编程中 接口是一种规范的定义 他定义了行为和动作的规范 在程序设计里面 接口起到一种限制和规范的作用 接口定义了某一批类所需要遵守的规范 接口不关系这些类的内部状态数据 也不关心这些类里方法的实现细节 他只规定这批类里必须提供某些方法 提供这些方法的类可以满足实际需求 typescript中的接口类似于java 同时还增加了更灵活的接口 类型 包括属性 函数可索引和类等 接口: 行为和动作的规范 对批量方法进行约束通过interface这个关键字来定义接口 属性类接口 1234567891011121314//需求必须传入对象 firstname 和secondname interface fullName&#123; firstname:string;//注意分号结束 secondname:string; &#125; function pt(name:fullName)&#123; console.log(name.firstname+&quot;======&quot;+name.secondname); &#125; var obj=&#123;/* 传入的参数必须包括firstname和secondname */ firstname:&quot;zhang&quot;, secondname:&apos;san&apos; &#125; pt(obj) 可选属性接口 1234567891011interface fullname&#123; firstname:string secondname?:string//?可传可不传 &#125; function getname(name:fullname)&#123; console.log(name); &#125; getname(&#123; // secondname:&quot;ahfoa&quot;, firstname:&quot;mmmm&quot; &#125;) 函数类型的接口:对方法传入的参数以及返回值进行约束 123456789//对传入的参数以及返回值进行约束 批量约束interface encrypt&#123; (key:string,value:string):string;&#125;var abs:encrypt=function(key:string,value:string):string&#123; return key+value;&#125;abs(&quot;name&quot;,&quot;zhangs&quot;)console.log(abs(&quot;name&quot;,&quot;zhangs&quot;)); 可索引接口和类类型接口 可索引接口:数组对象的约束 12345678910111213interface arrs&#123; [index:number]:string &#125; var arr1:arrs=[&quot;123&quot;,&quot;bbb&quot;] console.log(arr1[0]); interface obj&#123; [index:string]:string &#125; var srr1:obj=&#123; name:&quot;zhangshang&quot;, name1:&quot;lisi&quot; &#125; console.log(srr1.name); * 类类型接口:对类的约束 (和抽象类有点类似) implements123456789101112131415interface animer&#123; name:string; eat(str:string):void &#125; class Bog implements animer&#123; name:string constructor(name:string)&#123; this.name =name; &#125; eat()&#123; console.log(this.name+&apos;吃狗粮&apos;); &#125; &#125; var d = new Bog(&quot;啊黄&quot;) d.eat() 接口的扩展接口可以继承接口 1234567891011121314151617181920212223interface anmor&#123; eat():void;&#125;interface Person extends anmor&#123; work():void;&#125;class Web implements Person&#123; public name:string; constructor (name:string)&#123; this.name=name; &#125; eat()&#123; console.log(this.name+&apos;xihua&apos;); &#125; work()&#123; this.name+&quot;xiedaima&quot;; console.log(this.name+&quot;xiedaima&quot;); &#125;&#125;var b = new Web(&quot;小李&quot;)b.eat()b.work() 1.6泛型 解决类 接口 方法的重用性 以及对不特定数据类型的支持 泛型可以支持不特定的数据类型 泛型 1234567891011// T 表示泛型 具体什么类型是调用这个方法的时候决定的 function getData&lt;T&gt;(value:T):T&#123;//这个T可以是任意大写字母 但是这三个必须是一样的最好是用T return value; &#125; getData&lt;number&gt;(123) getData&lt;string&gt;(&quot;2313&quot;) function getData1&lt;T&gt;(value:T):any&#123; return value; &#125; getData1&lt;number&gt;(123)//参数必须是number getData1&lt;string&gt;(&quot;2313&quot;)//参数必须是string 泛型类 1234567891011121314151617181920212223242526272829// 泛型类class Min&lt;T&gt;&#123; public list :T[]=[]; add(num:T)&#123; this.list.push(num) &#125; min():T&#123; var minNum=this.list[0]; for(var i = 0;i&lt;this.list.length; i++)&#123; if(minNum&gt;this.list[i])&#123; minNum=this.list[i] &#125; &#125; return minNum; &#125;&#125;var m = new Min&lt;number&gt;()//实例化类 并且制定了类的代表类型是numberm.add(8)m.add(22)m.add(82)m.add(3)console.log(m.min())var m1 = new Min&lt;string&gt;()//实例化类 并且制定了类的代表类型是numberm1.add(&quot;b&quot;)m1.add(&quot;a&quot;)m1.add(&quot;c&quot;)m1.add(&quot;d&quot;)console.log(m1.min()) 泛型的接口1234567891011121314151617interface Config&#123; &lt;T&gt;(value:T):T&#125;var setData:Config=function&lt;T&gt;(value:T):T&#123; return value&#125;setData(&quot;name&quot;)console.log(setData&lt;string&gt;(&quot;name&quot;));interface Configs&lt;T&gt;&#123; (value:T):T&#125;function getData&lt;T&gt;(value:T):T&#123; return value&#125;var setDatas:Configs&lt;string&gt;=getData;setDatas(&quot;20&quot;)console.log(setDatas(&quot;20&quot;)); 1.7类作为参数来约束数据传入的类型 12345678910111213141516171819202122232425262728293031323334353637class Mysql&lt;T&gt;&#123; add(info:T):boolean&#123; console.log(info); return true; &#125;&#125;// 定义一个user类 在数据库中进行映射class User&#123; username:string|undefined; password:string|undefined;&#125;var u = new User();u.username=&quot;zhangs&quot;;u.password=&quot;lis&quot;;var m=new Mysql&lt;User&gt;();m.add(u);// 定义一个wen类 class Wen&#123; title:string|undefined; desc:string|undefined; status:number|undefined; constructor(params:&#123; title:string|undefined, desc:string|undefined, status?:number|undefined &#125;)&#123; this.title=params.title this.desc=params.desc this.status=params.status &#125;&#125;var w = new Wen(&#123; title:&apos;文章标题&apos;, desc:&apos;abcdefghijklmnopqrstuvwxyz&apos;&#125;);var b=new Mysql&lt;Wen&gt;()b.add(w)","categories":[],"tags":[]},{"title":"hexo搭建","slug":"hexo搭建","date":"2019-11-22T06:08:48.837Z","updated":"2019-11-22T06:08:48.838Z","comments":true,"path":"2019/11/22/hexo搭建/","link":"","permalink":"http://yoursite.com/2019/11/22/hexo%E6%90%AD%E5%BB%BA/","excerpt":"","text":"hexo搭建 安装nodejs(hexo需要node支持) 安装hexo框架 npm install -g hexo-cli 可以用hexo -v 验证是否安装成功 新建文件夹 在新建文件夹内按住shift右击打开poweshell窗口 或者cmd进入该文件夹内 输入命令hexo init(过程可能需要几分钟 具体看你网络状态) 启动博客 hexo s 在本地localhost:4000端口启动部署到github上 去github创建库 命名 你的昵称.github.io 安装git部署插件 在命令行中输入 npm install –save hexo-deployer-git可忽略 更改配置文件 __config.yml冒号后边要加空格4.部署上去 hexo d (需要输入git用户名密码)然后就可以通过仓库名来访问博客了","categories":[],"tags":[]}]}